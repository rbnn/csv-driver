#!/bin/bash

# Author:   Ronny Biemann
#           Copyright 2016
# File:     xawk2
# License:  GPL-3.0

set -e
source xbase

# Define pattern for valid columns
awk_column_regex='[A-Za-z_][A-Za-z0-9_]*'

# Prefix/Suffix used for column names
awk_column_prefix='\$_'
awk_column_suffix=''

# Initialize default field-separator
fsep=$(set_fsep)

# Parse command line arguments and feed parsed arguments
declare -r program_name=${0##*/}
args=$(getopt -o t:hHEdD -l help,prefix:,suffix:,pattern: -n "${program_name}" -- "$@")
eval set -- "$args"

# Parse arguments
while true; do
  case $1 in
    -t)
      # Change field sepearator (default is comma)
      fsep=$(set_fsep $2)
      shift 2
      ;;

    -H)
      # Suppress header in output
      no_header=1
      shift
      ;;

    -E)
      # Feed header to command
      exec_header=1
      shift
      ;;

    -d)
      # Dry-run, don't execute the command but print what would have been done
      dry_run=1
      shift
      ;;

    -D)
      # Dry-run, don't execute the command but also print the compiled program
      dry_comp=1
      shift
      ;;

    --prefix)
      # Change column-name prefix
      awk_column_prefix=$2
      shift 2
      ;;

    --suffix)
      # Change column-name suffix
      awk_column_suffix=$2
      shift 2
      ;;

    --suffix)
      # Change column-name suffix
      awk_column_suffix=$2
      shift 2
      ;;

    --pattern)
      # Change column-name pattern
      awk_column_regex=$2
      shift 2
      ;;

    -h|--help)
      cat << EOF
Usage: ${program_name} [OPT] FILE
       ${program_name} [OPT] PROGRAM...

${program_name} executes AWK-programs after translating column names into column
numbers. Therefore ${program_name} reads the header information from stdin. The
header information is taken from the first line presented via stdin and is split
on occurrences of FS. It automatically checks, that all requested columns are
found in the header. On success ${program_name} replaces all occurences of a
column-name by its corresponding index and executes the resulting program. On
error ${program_name} fails with an error message.

Available flags for OPT:
  -t FS       Use FS as field separator
  -d          Dry-run: Don't execute anything, but print what would be executed.
  -D          Dry-run: Like -d flag, but only print the resulting program.
  -H          Suppress header in final output
  -E          Insert header into data stream
  --prefix=P  Set regular expression for column name prefix
  --suffix=S  Set regular expression for column name suffix
  --pattern=X Set regular expression for column name
  -h|--help   Show this message and terminate

Column names
${program_name} uses regular expressions to identify column names within the
AWK-program. Column names must consist of a valid AWK-variable plus a prefix and
suffix. This behavior can be changed by using the --prefix, --suffix and
--pattern flags. By default column names are detected by following expression:
      ${awk_column_prefix}${awk_column_regex}${awk_column_suffix}

This expression is used as extended regular expression like in EGREP.

SEE ALSO
  awk(1), egrep(1)
EOF
      shift
      exit 0
      ;;
 
    --)
      shift
      break
      ;;
  esac
done

# Full pattern to identify column names within AWK-scripts
awk_variable_pattern="${awk_column_prefix}${awk_column_regex:?Invalid variable pattern}${awk_column_suffix}"

# Check, whether given argument is an awk-script-file. Otherwise dump all
# arguments into a temporary file. This allows passing awk-program directly via
# command line.
if [ -r "${1:?Missing awk-program}" ]; then
  # The first argument is an awk-script-file
  declare -r awk_in_file="${1:?Missing awk-script}"

else
  # Dump program passed via command line into temporary file.
  declare -r awk_in_file=$(mktemp)
  declare -r awk_in_temp="yes"
  echo "$@" > "${awk_in_file}"

fi

# Input/Output script
declare -r awk_out_file=$(mktemp)

# Find all column names in AWK-script
declare -ra code_symbols=($(egrep -o "${awk_variable_pattern}" "${awk_in_file}" | sort | uniq))
declare -a fields

# Set input field separator from variable or default
IFS= read -r raw_header

# Parse head line into x_fields and x_flags
parse_header "$raw_header" "$fsep" x_

if [ 0 -ne ${#code_symbols[@]} ]; then
  # Try resolving columns only if, any could be found in the original script.
  # This branch is skipped if no variables were found.
  for sym in "${code_symbols[@]}"; do
    tmp=${sym##$awk_column_prefix}
    tmp=${tmp%%$awk_column_suffix}
  
    cnt=${#fields[@]}
    fields[$cnt]="$tmp"
  done
  
  # Find columns in x_fields and store indices into x_index and x_found
  find_fields x_fields[@] x_ ${fields[@]}
  
  # Calculate arguments for
  declare -a sed_args
  for ((i = 0; i < ${#x_index[@]}; i += 1)); do
    sym=${code_symbols[$i]:?Invalid symbol}
    # Escape `$' by `\$' for sed-expression
    pat=${sym//\$/\\\$}
    idx=${x_index[$i]:?Invalid index}
    num=$((idx + 1))
  
    # echo "$sym --> $pat --> $idx"
  
    # Generate a sed-expression for every column name.
    # This expression will replace the column name by its column index.
    cnt=${#sed_args[@]}
    sed_args[$cnt]="-e s/${pat}/\$$num/g"
  done
  
  # Search & replace column names in AWK-script
  sed "${sed_args[@]}" "$awk_in_file" > "$awk_out_file"
  
  # Execute AWK-script
  cmd=$(replace_fsep "$_awk -F %fs -v OFS=%fs" "$fsep")
  cmd+=" -f '${awk_out_file}'"
else
  cat "${awk_in_file}" > "${awk_out_file}"
fi

# Execute command & script
if [ 0 -ne ${dry_run:-0} ] || [ 0 -ne ${dry_comp:-0} ]; then
  # Don't execute anything. Only print the command
  [ 0 -ne ${dry_run:-0} ] && echo "$cmd"

  # Don't execute anything. Only print the parsed script
  [ 0 -ne ${dry_comp:-0} ] && cat "$awk_out_file"

else
  # Optionally prepend(default) or suppress header to output
  [ 0 -eq ${no_header:-0} ] && echo ${raw_header}

  # Optionally insert header into body (not default)
  if [ 0 -eq ${exec_header:-0} ]; then cat
  else (echo ${raw_header} && cat)
  fi | eval ${cmd}
fi

# If the program was given via command-line, the temporary file has to be deleted.
[ "yes" = "${awk_in_temp}" ] && rm "${awk_in_file}"
rm "${awk_out_file}"
