#!/bin/sh

source ./xbase

program_name=${0##*/}
usage_message="Invalid usage! See \`$program_name --help' for help."

# Detect mode and configure command appropriately
case $program_name in
  xawk)
    # Detected awk-mode
    # OFS  --> Set output field separator
    # OFMT --> Configure default float format
    external="$_awk -F %fs -v OFMT=%.8f -v OFS=%fs"
    format="-v _%n=%i"
    options=-A
    special_mode=1
    ;;

  xfind)
    # Detect find-mode
    external="$_echo"
    format="%i"
    options=-H
    special_mode=1
    ;;

  xshuf)
    # Detected shuf-mode
    external="$_shuf"
    format=
    options=
    special_mode=1
    ;;

  xsort)
    # Detected sort-mode
    external="$_sort -t %fs"
    format="--key=%i,%i%o"
    options=
    special_mode=1
    ;;
esac

# Initialize default field-separator
fsep=$(set_fsep)

# Parse command line arguments and feed parsed arguments
args=$(getopt -o f:t:o:c:hAHEd -l help -n "$program_name" -- $options "$@")
eval set -- "$args"

declare -a fields

# Parse arguments
while true; do
  case $1 in
    -f)
      # Specify field
      cnt=$((${#fields[@]} + 1))
      fields[$cnt]=${2:?Invalid field name}
      shift 2
      ;;

    -t)
      # Change field sepearator (default is comma)
      fsep=$(set_fsep $2)
      shift 2
      ;;

    -o)
      # Print warning if overwriting mode-default
      [ 0 -ne ${special_mode:-0} ] && warning "Overwriting mode-specific format!"

      format=$2
      shift 2
      ;;

    -c)
      # Print warning if overwriting mode-default
      [ 0 -ne ${special_mode:-0} ] && warning "Overwriting mode-specific command!"

      # Run external command on body
      external=${2:?Invalid command}
      shift 2
      ;;

    -A)
      # Select all columns
      select_all=1
      shift
      ;;

    -H)
      # Suppress header in output
      no_header=1
      shift
      ;;

    -E)
      # Feed header to command
      exec_header=1
      shift
      ;;

    -d)
      # Dry-run, don't execute the command but print what would have been done
      dry_run=1;
      shift
      ;;

    -h|--help)
      # Print help message
      cat << EOF
Usage: $program_name [OPT..] [-- ...]   -- driver for external program

This tool helps running external programs with data files, that contain header
information (e.g. CSV with header). The command generation for an external
program is controlled via format-options to translate field-names into
column-indices. Some frequently used external programs are preconfigured and
can be accessed fast by linking this tool to the appropriate target:
  ln xdriver xawk  -- Enable (m)awk mode
  ln xdriver xfind -- Find column index
  ln xdriver xshuf -- Enable gnu-shuf from coreutils
  ln xdriver xsort -- Enable gnu-sort from coreutils

Available options:
  -f FIELD[:FOPT] Find index for FIELD in header, or fail. Field-OPTions can be
                  specified (e.g. for sort). This option may appear multiple times.
  -t FS           Use FS as field separator (default: $default_fsep)
  -o FMT          Use FMT to generate the result for field indices. Tokens
                  '%n', '%i' and '%o' will be replaced by FIELD, OPT or the
                  field index. This option should not be used, when a special
                  mode is detected, as it will overwrite mode-specifi options.
  -c CMD          Run CMD with FMT-results. The options gerenated by FMT are
                  appended. Also options passed after '--' are passed as they
                  are. This option should not be used, when a special mode is
                  detected, as it will overwrite mode-specifi options.
  -A              Select all columns
  -H              Disable writing the input header.
  -E              Pass the input header to CMD.
  -d              Do not run CMD, but print what would be done.
  -h, --help      Print this message and terminate

Following input are equivalent to special modes:
  xawk  --> -c $_awk -F %fs -v OFMT=%.8f -v OFS=%fs -o '-v column_%n=%i'
  xfind --> -c $_echo -o '%i' -H
  xshuf --> -c $_shuf
  xsort --> -c $_sort -t %fs -o '--key=%i,%i%o'
EOF
      exit 0
      ;;
 
    --)
      shift
      break
      ;;
  esac
done

[ -z "$external" ] && die -1 "Missing external command"

# Set input field separator from variable or default
IFS= read -r raw_header

# Parse head line into x_fields and x_flags
parse_header "$raw_header" "$fsep" x_

if [ 0 -eq ${select_all:-0} ]; then
  # Find columns in x_fields and store indices into x_index and x_found
  find_fields x_fields[@] x_ ${fields[@]}
else
  select_all_fields x_fields[@] x_
fi

cmd=$(replace_fsep "$external" "$fsep")

for i in `seq 1 "${#x_index[@]}"`; do 
  idx=$((i - 1))
  _C=${x_index[$idx]}
  _O=${x_flags[$idx]}
  _N=${x_fields[$_C]}
  _I=$((_C + 1))

  cmd+=" "$(sed -e "s|%n|$_N|g" -e "s|%i|$_I|g" -e "s|%o|$_O|g" <<< "${format:-"%i"}")
done

# Optionally prepend(default) or suppress header to output
[ 0 -ne ${no_header:-${dry_run:-0}} ] || echo $(join_by x_fields[@] $fsep)

# Prepend echo-command for dry-run-mode
[ 0 -ne ${dry_run:-0} ] && cmd="$_echo ""$cmd"

# Optionally insert header into body (not default)
if [ 0 -eq ${exec_header:-0} ]; then cat
else (echo $(join_by x_fields[@] $fsep) && cat)
fi | $cmd "$@"
