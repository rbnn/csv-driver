#!/bin/bash

set -e
source xbase

# Define pattern for valid columns
awk_column_regex='[A-Za-z_][A-Za-z0-9_]*'

# Prefix/Suffix used for column names
awk_column_prefix='\$_'
awk_column_suffix=''

# Initialize default field-separator
fsep=$(set_fsep)

# Parse command line arguments and feed parsed arguments
args=$(getopt -o t:hHEdD -l help,prefix:,suffix:,pattern: -n "${0##*/}" -- "$@")
eval set -- "$args"

# Parse arguments
while true; do
  case $1 in
    -t)
      # Change field sepearator (default is comma)
      fsep=$(set_fsep $2)
      shift 2
      ;;

    -H)
      # Suppress header in output
      no_header=1
      shift
      ;;

    -E)
      # Feed header to command
      exec_header=1
      shift
      ;;

    -d)
      # Dry-run, don't execute the command but print what would have been done
      dry_run=1
      shift
      ;;

    -D)
      # Dry-run, don't execute the command but also print the compiled program
      dry_comp=1
      shift
      ;;

    --prefix)
      # Change column-name prefix
      awk_column_prefix=$2
      shift 2
      ;;

    --suffix)
      # Change column-name suffix
      awk_column_suffix=$2
      shift 2
      ;;

    --suffix)
      # Change column-name suffix
      awk_column_suffix=$2
      shift 2
      ;;

    --pattern)
      # Change column-name pattern
      awk_column_regex=$2
      shift 2
      ;;

    -h|--help)
      cat << EOF
  -t FS   Use FS as field separator
  -d      Dry-run. Don't execute anything
  -D      Dry-run. Only print column-name replacement
  -H      Suppress output of header
  -E      Pass header in body
  --prefix=P  Use P as prefix for column-name
  --suffix=S  Use S as suffix for column-name
  --pattern=X Use X as pattern for column-names
  -h|--help   Show this message and terminate

Columns are identified by the pattern <P><X><S>
EOF
      shift
      exit 0
      ;;
 
    --)
      shift
      break
      ;;
  esac
done

# Full pattern to identify column names within AWK-scripts
awk_variable_pattern="${awk_column_prefix}${awk_column_regex:?Invalid variable pattern}${awk_column_suffix}"

# Input/Output script
awk_in="${1:?Missing awk-script}"
awk_out=$(mktemp)

# Find all column names in AWK-script
declare -ra code_symbols=($(egrep -o "${awk_variable_pattern}" "$awk_in" | sort | uniq))
declare -a fields

# Set input field separator from variable or default
IFS= read -r raw_header

# Parse head line into x_fields and x_flags
parse_header "$raw_header" "$fsep" x_

if [ 0 -ne ${#code_symbols[@]} ]; then
  # Try resolving columns only if, any could be found in the original script.
  # This branch is skipped if no variables were found.
  for sym in "${code_symbols[@]}"; do
    tmp=${sym##$awk_column_prefix}
    tmp=${tmp%%$awk_column_suffix}
  
    cnt=${#fields[@]}
    fields[$cnt]="$tmp"
  done
  
  # Find columns in x_fields and store indices into x_index and x_found
  find_fields x_fields[@] x_ ${fields[@]}
  
  # Calculate arguments for
  declare -a sed_args
  for ((i = 0; i < ${#x_index[@]}; i += 1)); do
    sym=${code_symbols[$i]:?Invalid symbol}
    # Escape `$' by `\$' for sed-expression
    pat=${sym//\$/\\\$}
    idx=${x_index[$i]:?Invalid index}
    num=$((idx + 1))
  
    # echo "$sym --> $pat --> $idx"
  
    # Generate a sed-expression for every column name.
    # This expression will replace the column name by its column index.
    cnt=${#sed_args[@]}
    sed_args[$cnt]="-e s/${pat}/\$$num/g"
  done
  
  # Search & replace column names in AWK-script
  sed "${sed_args[@]}" "$awk_in" > "$awk_out"
  
  # Execute AWK-script
  cmd=$(replace_fsep "$_awk -F %fs -v OFS=%fs" "$fsep")
  cmd+=" -f '$awk_out'"
else
  cat "$awk_in" > "$awk_out"
fi

# Execute command & script
if [ 0 -ne ${dry_run:-0} ]; then
  # Don't execute anything. Only print the command
  echo "$cmd"

elif [ 0 -ne ${dry_comp:-0} ]; then
  # Don't execute anything. Only print the parsed script
  cat "$awk_out"

else
  # Optionally prepend(default) or suppress header to output
  [ 0 -eq ${no_header:-0} ] && echo ${raw_header}

  # Optionally insert header into body (not default)
  if [ 0 -eq ${exec_header:-0} ]; then cat
  else (echo ${raw_header} && cat)
  fi | eval $cmd
fi

rm "$awk_out"
